<!DOCTYPE html>
<html lang="en">
  <head>
    <meta name="generator" content="HTML Tidy for HTML5 for Linux version 5.6.0">
    <meta charset="utf-8" compile-date="2025-06-13 14:47:14" content="width=device-width, initial-scale=1" name="viewport">
    <link href="project.css" rel="stylesheet" type="text/css">
    <title>
      trlisp — A Lisp-y implementation of B. Jay's unlabelled binary tree calculus
    </title>
  </head>
  <body>
    <a href="https://clojars.org/com.sagevisuals/trlisp"><img src="https://img.shields.io/clojars/v/com.sagevisuals/trlisp.svg"></a><br>
    <a href="#setup">Setup</a><br>
    <a href="https://blosavio.github.io/trlisp/index.html">API</a><br>
    <a href="https://github.com/blosavio/trlisp/blob/main/changelog.md">Changelog</a><br>
    <a href="#intro">Introduction</a><br>
    <a href="#usage">Usage</a><br>
    <a href="#fundamental">Fundamental functions</a><br>
    <a href="#base">Base functions</a><br>
    <a href="#comments">Comments</a><br>
    <a href="#references">References</a><br>
    <a href="#glossary">Glossary</a><br>
    <a href="https://github.com/blosavio">Contact</a><br>
    <h1>
      trlisp
    </h1><em>A Lisp-y implementation of B. Jay's unlabelled binary tree calculus</em><br>
    <section id="setup">
      <h2>
        Setup
      </h2>
      <h3>
        Leiningen/Boot
      </h3>
      <pre><code>[com.sagevisuals/trlisp "0-SNAPSHOT0"]</code></pre>
      <h3>
        Clojure CLI/deps.edn
      </h3>
      <pre><code>com.sagevisuals/trlisp {:mvn/version "0-SNAPSHOT0"}</code></pre>
      <h3>
        Require
      </h3>
      <pre><code>(require '[tree-calculus.definitions :refer :all])</code></pre>
    </section>
    <section id="intro">
      <h2>
        Introduction
      </h2>
      <p>
        Barry Jay's unlabelled binary <a href="https://github.com/barry-jay-personal/tree-calculus/blob/master/tree_book.pdf">tree calculus</a> is
        <em>reflective</em>, which means we can inspect the internal structure of every function. Without quotation, every function is always open to:
      </p>
      <ul>
        <li>
          <strong>Inspection</strong> We may view the function's structure and contents.
        </li>
        <li>
          <strong>Analysis</strong> We may measure the function's size, etc.
        </li>
        <li>
          <strong>Comparison</strong> We may test two functions for equality, equivalence, etc.
        </li>
        <li>
          <strong>Optimization</strong> We may precompute some static branch of a function, or alter it for more efficiency.
        </li>
        <li>
          <strong>Decomposition</strong> We may pull out different pieces of a function, perhaps for use in a different context.
        </li>
        <li>
          <strong>Modification</strong> We may change some facet of the function at runtime to suit our needs.
        </li>
      </ul>
      <p></p>
      <p>
        <em>trlisp</em> is an implementation of tree calculus with the small, regular grammar of Lisp. The element at the head of a list, the function
        position, is invoked, with the elements of the tail of the list providing the arguments. Unlike traditional Lisps, <em>trlisp</em> functions may be
        transparently decomposed so that the function may be inspected, analyzed, compared, optimized, decomposed, and modified, without the need for
        quotation. That is to say, trlisp functions are reflective.
      </p>
      <p>
        <em>trlisp</em> is intended to be used to explore practical questions such as
      </p>
      <ul>
        <li>How useful is it to have unquoted access to the contents of a function?
        </li>
        <li>Can new functions be composed from pulled-apart pieces of others?
        </li>
        <li>Could a function be automatically inverted?
        </li>
      </ul>
      <p></p>
    </section>
    <section id="usage">
      <h2>
        Usage
      </h2>
      <h3>
        Lisp-y
      </h3>
      <section id="lisp">
        <p>
          <em>trlisp</em> inherits its evaluation model from its host, Clojure, a Lisp dialect. In Lisp, the fundamental evaluation unit is a list enclosed in
          parentheses. The first element of the list is the function, and any trailing list elements are the function's arguments, like this.
        </p>
        <pre><code>(function argument-1 argument-2 ... argument-n)</code></pre>
        <p>
          If we'd like to sum the integers two and three, we'd write this.
        </p>
        <pre><code>(+ 2 3)</code></pre>
        <p>
          In this example, the parentheses contain the expression we'd like to evaluate. The symbol for addition, <code>+</code>, is the first element, so it
          serves as the function. The trailing elements, integers <code>2</code> and <code>3</code>, supply the two arguments to <code>+</code>.
        </p>
        <p>
          When we evaluate the expression <code>(+ 2 3)</code>, we obtain a value, integer <code>5</code>.
        </p>
        <pre><code>(+ 2 3) ;; =&gt; 5</code></pre>
        <p>
          trlisp follows this model. Parenthesized lists form a unit of evaluation, with the function at the head of the list applying to zero or more
          arguments in the tail.
        </p>
      </section>
      <h3>
        <code>Δ</code>, the do-everything operator
      </h3>
      <p>
        A notable aspect of tree calculus is that every <em>thing</em>, functions as well as values, is composed of a single, basic unit, <code>Δ</code>. So we
        must continually keep in mind that there is not a strict delineation between tree calculus functions, such as the <code>+</code> function, and tree
        calculus scalar values, such as integer <code>3</code>. Every entity in tree calculus is a binary tree composed only of different patterns of
        <code>Δ</code>. The application rules govern the how one or two trees produce another tree.
      </p>
      <p>
        Tree calculus defines six application rules. Five rules are the result of dispatching on whether the tree in the function position of the list is a
        leaf, stem, or fork, the last of which further dispatches on whether the left child is a leaf, stem, or fork.
      </p>
      <p>
        The sixth rule is merely the degenerate case with zero arguments, which we'll discuss first.
      </p>
      <h4 id="apply-leaf-to-nothing">
        Rule 0: Applying a leaf to nothing
      </h4>
      <p>
        Let's imagine a picture of the first rule: applying a leaf to nothing.
      </p>
      <pre><code>Δ</code></pre>
      <p>
        It doesn't look like much. Just a Greek delta character floating on the page, but as the rules progress and we add more elements, our picture will
        become more informative.
      </p>
      <p>
        Applying the <code>Δ</code> operator to zero arguments returns merely itself. We put the node symbol in function position of the list, followed by zero
        arguments, and evaluate the expression.
      </p>
      <pre><code>(Δ)</code></pre>
      <p>
        This returns a single tree node with zero children.
      </p>
      <p>
        Often times a function definition will involve a bare leaf in the middle of a sequence of applications, so those parentheses might get visually
        distracting. If we only need a bare leaf, we may skip the parentheses.
      </p>
      <pre><code>(= (Δ) Δ) ;; =&gt; true</code></pre>
      <p>
        We can see that <code>(Δ)</code> and <code>Δ</code> are equivalent.
      </p>
      <h4 id="apply-leaf-to-something">
        Rule 1: Applying a leaf to something
      </h4>
      <p>
        Now our picture is growing. Since we are applying a leaf to something, we'll imagine a leaf as before, plus something else standing to its right. Let's
        call it <code>z</code>.
      </p>
      <pre><code>Δ     z</code></pre>
      <p>
        <code>z</code> will be some unspecified tree that can be operated on, either another leaf, a stem, or some unspecified fork.
      </p>
      <p>
        To be exceedingly explicit, let's introduce a symbol <code>␣</code> to visually separate the function and the argument.
      </p>
      <pre><code>Δ  ␣  z</code></pre>
      <p>
        We can interpret that picture as <em>Function <code>Δ</code> applied to argument <code>z</code>.</em>
      </p>
      <p>
        As with all Lisps, trlisp uses parentheses for function invocation. To evaluate that expression, we put the function <code>Δ</code> at the head of the
        list and the single argument <code>z</code> in the tail.
      </p>
      <pre><code>(Δ z)</code></pre>
      <p>
        A Lisp programmer would read that expression as <em>Function <code>Δ</code> applied to argument <code>z</code>.</em>
      </p>
      <p>
        When the <code>Δ</code> function is evaluated with one argument, a stem results with the argument forming the single child branch. Here is a picture of
        the result.
      </p>
      <pre><code>Δ
|
z</code></pre>
      <p>
        The expression returns a stem: a root node at the top, with a single child element <code>z</code> branching straight off its bottom.
      </p>
      <h4 id="apply-stem">
        Rule 2: Applying a stem
      </h4>
      <p>
        Let's visualize applying a stem to something.
      </p>
      <pre><code>Δ
|  ␣  z
x</code></pre>
      <p>
        The stem, serving as our function, is on the left and applies to the argument immediately to its right, the <code>z</code>, which may be any valid
        tree.
      </p>
      <p>
        To evaluate this in trlisp, we put a stem in the function position and the argument in the tail. Let's take it step by step. To compose the function, a
        stem, we'll recall the <a href="#apply-leaf-to-something">previous subsection</a> where we constructed a stem by applying a leaf node to something.
      </p>
      <pre><code>(Δ x)</code></pre>
      <p>
        The stem we just now composed consists of a root node at top and an unspecified child tree <code>x</code>.
      </p>
      <p>
        Now we have a stem in hand to serve as a function. We place that stem at the head of our list, followed by the argument, some unspecified tree
        <code>z</code>.
      </p>
      <pre><code>((Δ x) z)</code></pre>
      <p>
        Tree calculus declares that evaluating that expression yields a fork, with <code>x</code> forming the left child branch and <code>z</code> forming the
        right child branch.
      </p>
      <p>
        We could visualize the result like this.
      </p>
      <pre><code>  Δ
 / \
x   z</code></pre>
      <p>
        Root node at top and children, in order, branching off the bottom.
      </p>
      <p>
        An <a href="#variadic">upcoming section</a> discusses ways to write this more efficiently.
      </p>
      <p>
        Note that application Rules&nbsp;0, 1, and&nbsp;2 form a basis for constructing trees. Applying a bare leaf to nothing returns a leaf. Applying a leaf
        to something creates a stem. And applying a stem creates a fork.
      </p>
      <p>
        Application Rules&nbsp;3, 4, and&nbsp;5 involve applying three varieties of forks. When applying a fork, trlisp dispatches on whether the left child
        itself is a leaf, stem, or fork.
      </p>
      <h4 id="apply-fork-leaf">
        Rule 3: Applying a fork with left child leaf
      </h4>
      <p>
        Here is a picture of applying a fork, where the left child is a leaf, to an argument <code>z</code>.
      </p>
      <pre><code>  Δ
 / \   ␣  z
Δ   y</code></pre>
      <p>
        Both the right child branch <code>y</code> and argument <code>z</code> can be any valid tree.
      </p>
      <p>
        To express this application in trlisp, let's first construct the function, a fork. We know how to construct a fork from the <a href=
        "#apply-stem">previous subsection</a>. A fork is constructed by applying a stem to something, and a stem itself is constructed by applying a leaf to
        something. We'll do each step in turn.
      </p>
      <p>
        The left branch of our function is a leaf, so we need a root node and a child <code>Δ</code>. To construct a stem, we apply a leaf to another leaf.
      </p>
      <pre><code>(Δ Δ)</code></pre>
      <p>
        We visualize that resulting stem like this.
      </p>
      <pre><code>Δ
|
Δ</code></pre>
      <p>
        Now that we have a stem, we know from Rule&nbsp;2 that applying a stem to something constructs a fork. So we can apply that stem to some branch
        <code>y</code>.
      </p>
      <pre><code>((Δ Δ) y)</code></pre>
      <p>
        Which produces a tree that will serve as our function.
      </p>
      <pre><code>  Δ
 / \
Δ   y</code></pre>
      <p>
        A root node at top, a leaf node is the left child, and some subtree <code>y</code> is the right child.
      </p>
      <p>
        Finally, we insert this function at the head of the list and supply <code>z</code> as the argument in the tail position.
      </p>
      <pre><code>(((Δ Δ) y) z)</code></pre>
      <p>
        Tree calculus declares that if the left child of a fork is a leaf, application of that fork to anything returns the fork's right branch and discards
        the argument. In this case, the function's right child is <code>y</code>, which is returned.
      </p>
      <p>
        One way to look at this is the sequential application of a stem to two arguments <code>y</code> then <code>z</code>.
      </p>
      <pre><code>Δ
|  ␣  y  ␣  z
Δ</code></pre>
      <p>
        This is a pattern that we see repeatedly in tree calculus: Applying a stem to two arguments selects the first of two arguments <code>y</code> and
        discards the second argument <code>z</code>.
      </p>
      <p id="forgiving">
        trlisp strives to be forgiving when it comes to parentheses. We can discard any pair of parentheses if the implied left-association holds. The
        following
      </p>
      <pre><code>(((Δ Δ) y) z)</code><br><code> ((Δ Δ) y  z)</code><br><code> ((Δ Δ  y) z)</code><br><code>  (Δ Δ  y  z)</code></pre>
      <p>
        are all equivalent: All return <code>y</code>.
      </p>
      <h4 id="apply-fork-stem">
        Rule 4: Applying a fork with left child stem
      </h4>
      <p>
        Here is a picture of a function composed of a fork with a left child stem.
      </p>
      <pre><code>  Δ
 / \
Δ   y  ␣  z
|
x</code></pre>
      <p>
        Working up from the bottom, the left child stem is itself composed of a node with some unspecified tree <code>x</code> as it single child. To make this
        stem
      </p>
      <pre><code>Δ
|
x</code></pre>
      <p>
        we evaluate
      </p>
      <pre><code>(Δ x)</code></pre>
      <p>
        Then, to make our desired fork, we supply that stem as the left child branch and some unspecified tree <code>y</code> as the right child branch.
      </p>
      <pre><code>(Δ (Δ x) y)</code></pre>
      <p>
        Which evaluates to this picture.
      </p>
      <pre><code>  Δ
 / \
Δ   y
|
x</code></pre>
      <p>
        See the <a href="#forgiving">note</a> at the end of the previous subsection on why we're allowed to sometimes drop parentheses.
      </p>
      <p>
        Finally, we apply this function to some unspecified tree as argument <code>z</code> by inserting the function at the head of the list and the argument
        in the tail.
      </p>
      <pre><code>((Δ (Δ x) y) z)</code></pre>
      <p>
        Tree calculus declares this expression to evaluate to
      </p>
      <pre><code>((y z) (x z))</code></pre>
      <p>
        The order of the function's right child <code>y</code> and left grandchild <code>x</code> are swapped, and the argument <code>z</code> is broadcast to
        each. Then the result of the first evaluation is applied to the result of the second evaluation. This pattern often appears in definitions because it's
        useful to be able to swap two items.
      </p>
      <h4 id="apply-fork-fork">
        Rule 5: Applying a fork with left child fork
      </h4>
      <p>
        The final application rule involves a function whose left fork is itself a fork. Let's visualize that situation.
      </p>
      <pre><code>    Δ
   / \
  Δ   y  ␣  z
 / \
w   x</code></pre>
      <p>
        Examining the function on the left, we see a child fork with two branches, designated <code>w</code> and <code>x</code>. Using what we've discussed so
        far, let's construct this function from the bottom up. We know how to construct a fork, so let's make one with a left branch some unspecified
        <code>w</code> and right branch some unspecified <code>x</code>.
      </p>
      <pre><code>(Δ w x)</code></pre>
      <p>
        That trlisp expression creates this sub-tree.
      </p>
      <pre><code>  Δ
 / \
w   x</code></pre>
      <p>
        With that sub-tree in hand, let's move up one level. That sub-tree becomes the left child of the root node, while some unspecified tree <code>y</code>
        becomes the right child node.
      </p>
      <pre><code>(Δ (Δ w x) y)</code></pre>
      <p>
        Now we have this picture.
      </p>
      <pre><code>    Δ
   / \
  Δ   y
 / \
w   x</code></pre>
      <p>
        This is our function, which we insert into the head of our trlisp expression, followed by some unspecified argument <code>z</code>
      </p>
      <pre><code>((Δ (Δ w x) y) z)</code></pre>
      <p>
        to obtain our final expression.
      </p>
      <p>
        Tree calculus declares that this expression evaluates to the following.
      </p>
      <pre><code>(z w x)</code></pre>
      <p>
        Applying a fork with a left child fork results in applying the argument <code>z</code> to the decomposition of the function's left child's branches
        <code>w</code> and <code>x</code>. This pattern is useful when we need to pull apart a fork and send the pieces to a function.
      </p>
      <p>
        The next two subsections introduce a few conveniences.
      </p>
      <h4 id="variadic">
        Variadic application
      </h4>
      <p>
        trlisp provides a convenience to minimize parentheses: We may supply any number of arguments and trlisp will sequentially apply them by
        left-association. For example, when we evaluate the <code>Δ</code> function with two arguments, we obtain a fork. Let's supply two arguments,
        <code>x</code> and <code>y</code>, two unspecified trees.
      </p>
      <pre><code>(Δ x y)</code></pre>
      <p>
        When evaluated, this returns a fork, a node whose left child is some tree <code>x</code> and whose right child is <code>y</code>, some other tree.
        Under the hood, trlisp applied <code>Δ</code> to <code>x</code>, then applied that result to <code>y</code>, exactly as if we had evaluated
      </p>
      <pre><code>((Δ x) y)</code></pre>
      <p>
        This principle can be extended as needed. Five applications
      </p>
      <pre><code>(((((Δ Δ) Δ) Δ) Δ) Δ)</code></pre>
      <p>
        may be more succinctly written like this
      </p>
      <pre><code>(Δ Δ Δ Δ Δ Δ)</code></pre>
      <p>
        with the understanding that application is left-associative.
      </p>
      <h4>
        Variable binding and convenience functions
      </h4>
      <p>
        Usually, we'll find it convenient to forgo combinatory logic's goal of avoiding names. In those situations, we can rely on our host platform's variable
        binding to give meaningful names to commonly used trees. Clojure's <code>def</code> binds a name to a value.
      </p>
      <pre><code>(def foo (Δ Δ))</code></pre>
      <p>
        Here, we bound the Clojure symbol <code>foo</code> to a two-node stem. Now we can use <code>foo</code> in future expressions, and it will evaluate to
        <code>(Δ Δ)</code>.
      </p>
      <p>
        Also, we will sometimes find it convenient to use a lambda calculus-like expression. We can express
      </p>
      <pre><code>λa.λb.ab</code></pre>
      <p>
        as
      </p>
      <pre><code>(fn [a] (fn [b] (a b)))</code></pre>
      <p>
        in Clojure.
      </p>
      <p>
        In trlisp , such a function will appear hanging off a tree somewhere. We might see something like this.
      </p>
      <pre><code>    Δ
   / \
  Δ   y  ␣  z
 / \
w   (fn [a] (fn [b] (a b)))</code></pre>
      <p>
        trlisp's application machinery handles that tree without any additional effort from us.
      </p>
      <h4 id="application-summary">
        Application rules quick summary
      </h4>
      <p>
        Here are all six application rules at once. Notice that the first three rules describe how to construct a leaf, stem, or fork. The last three rules
        describe how to evaluate the application of a fork with a left child leaf, a left child stem, and left child fork, respectively.
      </p>
      <table>
        <tr>
          <td>
            <p>
              0. Apply leaf to nothing.
            </p>
          </td>
          <td>
            <pre><code>Δ ␣ </code></pre>
          </td>
          <td>
            <pre><code> (Δ)      = Δ</code></pre>
          </td>
        </tr>
        <tr>
          <td>
            <p>
              1. Apply leaf to something.
            </p>
          </td>
          <td>
            <pre><code>Δ ␣ z</code></pre>
          </td>
          <td>
            <pre><code>((Δ)   z) = (Δ   z)</code></pre>
          </td>
        </tr>
        <tr>
          <td>
            <p>
              2. Apply stem.
            </p>
          </td>
          <td>
            <pre><code>Δ
|  ␣  z
x</code></pre>
          </td>
          <td>
            <pre><code>((Δ x) z) = (Δ x z)</code></pre>
          </td>
        </tr>
        <tr>
          <td>
            <p>
              3. Apply fork-leaf.
            </p>
          </td>
          <td>
            <pre><code>  Δ
 / \   ␣  z
Δ   y</code></pre>
          </td>
          <td>
            <pre><code>((Δ  Δ      y) z) = y</code></pre>
          </td>
        </tr>
        <tr>
          <td>
            <p>
              4. Apply fork-stem.
            </p>
          </td>
          <td>
            <pre><code>  Δ
 / \
Δ   y  ␣  z
|
x</code></pre>
          </td>
          <td>
            <pre><code>((Δ (Δ   x) y) z) = ((y z) (x z))</code></pre>
          </td>
        </tr>
        <tr>
          <td>
            <p>
              5. Apply fork-fork.
            </p>
          </td>
          <td>
            <pre><code>    Δ
   / \
  Δ   y  ␣  z
 / \
w   x</code></pre>
          </td>
          <td>
            <pre><code>((Δ (Δ w x) y) z) = (z w x)</code></pre>
          </td>
        </tr>
      </table>
      <p>
        And that's it. One operator and six rules are all that is necessary for a combinatorially-complete system.
      </p>
      <h3 id="implementation">
        Implementation Note
      </h3>
      <p>
        Tree calculus trees have a dual nature: they are both structures and functions. That is, trees may <em>contain</em> an arbitrary pattern of
        descendants, but at the same time, they conceptually <em>apply</em> a transform to an argument. Any implementation must therefore capture these two
        properties.
      </p>
      <p>
        Clojure vectors are handy because, while they are exceedingly capable at storing and retrieving arbitrary values, they support an interface that allows
        them to behave as a Lisp function. For example, when a Clojure vector is placed in the function position of a list and an integer argument follows in
        the tail, the vector invokes an implied accessor function, <a href=
        "https://clojure.github.io/clojure/clojure.core-api.html#clojure.core/nth"><code>nth</code></a>, which returns the value at the index.
      </p>
      <p>
        For example, we could explicitly access the third element with <code>nth</code> like so.
      </p>
      <pre><code>;; plain Clojure</code><br><code>(nth [98 99 100] 2) ;; =&gt; 100</code></pre>
      <p>
        Equivalently, we could rely on a Clojure vector's ability to behave as a Lisp function.
      </p>
      <pre><code>;; plain Clojure</code><br><code>([98 99 100] 2) ;; =&gt; 100</code></pre>
      <p>
        Putting a vector at the head of a list is a widely-used Clojure idiom.
      </p>
      <p>
        Since Clojure hosts trlisp, the machinery is in place for vectors to serve a functions. We merely need to change that function from the accessor
        function <code>nth</code> to a different function that implements tree calculus' application rules.
      </p>
      <p>
        trlisp models a tree as an <a href="https://github.com/blosavio/thingy">altered Clojure vector</a> containing up to two other such altered vectors.
        These nested vectors provide the reified structure representing tree calculus' unlabelled binary trees.
      </p>
      <p>
        A single node is simply an empty vector, i.e., it has no descendants. We can observe this by evaluating a bare node.
      </p>
      <pre><code>(Δ) ;; =&gt; []</code></pre>
      <p>
        Applying the <code>Δ</code> function to nothing returns trlisp's literal representation, an empty vector.
      </p>
      <p>
        Let's consider a simple stem.
      </p>
      <pre><code>Δ
|
Δ</code></pre>
      <p>
        We can construct a node with a single child leaf by applying one node to another node.
      </p>
      <pre><code>(Δ Δ) ;; =&gt; [[]]</code></pre>
      <p>
        Now we see that the parent vector contains a single element, another vector of the same kind.
      </p>
      <p>
        We could have equivalently written the following.
      </p>
      <pre><code>([] []) ;; =&gt; [[]]</code></pre>
      <p>
        The first special vector in the function position <code>[]</code> applied to another special vector <code>[]</code> invokes tree calculus' application
        rules. In this case, according to Rule&nbsp;1, a leaf (empty vector) applied to another tree (also a leaf in this case), constructs a stem.
      </p>
      <p>
        Extending this principle further, consider this simple fork.
      </p>
      <pre><code>  Δ
 / \
Δ   Δ</code></pre>We can construct this fork by supplying the parent node with two child nodes.
      <pre><code>(Δ Δ Δ) ;; =&gt; [[] []]</code></pre>
      <p>
        Here we see that the root vector now contains two child vectors.
      </p>
      <p>
        trlisp's main usefulness in exploring tree calculus is the fact that these special vectors invoke the tree calculus application rules instead of the
        built-in <code>nth</code>.
      </p>
      <p>
        One practical consequence of using vectors this way is that rendering trees as nested empty vectors is not very ergonomic for human eyes. After some
        practice, it's not too difficult to mentally translate <code>(Δ Δ Δ)</code> to
      </p>
      <pre><code>  Δ
 / \
Δ   Δ</code></pre>
      <p>
        but it requires much more eyestrain to see that both are equivalent to
      </p>
      <pre><code>[[] []]</code></pre>
      <p>
        And it only gets worse as the trees grow beyond three nodes.
      </p>
      <p>
        One option is to use Clojure keywords to represent arbitrary subtrees. The evaluation of this expression
      </p>
      <pre><code>(Δ :a :b) ;; =&gt; [:a :b]</code></pre>
      <p>
        can be visualized like this.
      </p>
      <pre><code>   Δ
  / \
:a   :b</code></pre>
      <p>
        But we can't use this option when a Clojure keyword would end up in the function position of a tree application rule, like in Rule&nbsp;4,
      </p>
      <pre><code>;; this won't work</code><br><code>((:a :b) (:c :d))</code></pre>
      <p>
        because Clojure keywords don't implement the tree calculus application rules.
      </p>
      <p>
        In that case, we must define concrete trees to which to apply the rules.
      </p>
      <pre><code>(def h Δ)</code><br><code>(def i Δ)</code><br><code>(def j Δ)</code><br><code>(def k Δ)</code><br><br><code>((h i) (j k)) ;; =&gt; [[] [[]]]</code></pre>
      <p>
        The expression can now return a valid value, but we are still left with the problem of figuring out what the tree <code>[[] [[]]]</code> looks like.
      </p>
      <p>
        trlisp doesn't currently (and may never) have a utility which renders tree diagrams. When walking through our discussion, I will silently replace
        things like <code>[[] [[]]]</code> with its equivalent <code>(Δ Δ K)</code>.
      </p>
      <p>
        Just keep in mind that if you are evaluating trlisp expressions on your own computer, you will see <code>[[] [[]]]</code>.
      </p>
      <p>
        To illustrate how function trees apply to arguments trees and return other trees, we can test for equality with the expected value. For example,
        Rule&nbsp;2 tells us that a stem applied to an argument leaf returns a fork with the argument leaf as the right child.
      </p>
      <pre><code>((Δ Δ) Δ) ;; =&gt; [[] []]</code></pre>
      <p>
        That's...okay. But working it out with pencil and paper, we expect it to return <code>(Δ Δ Δ)</code>. Is that the case?
      </p>
      <pre><code>(= ((Δ Δ) Δ)
   (Δ Δ Δ)) ;; =&gt; true</code></pre>
      <p>
        Yup. The value returned from the original application, in the upper row, is equal to the value returned by the expression in the lower row. By directly
        comparing return values with <code>=</code>, we don't have to squint at a pile of nested square brackets.
      </p>
      <h3 id="conventions">
        Conventions
      </h3>
      <p>
        Clojure names are <code>lower-case-with-hyphens</code>, such as <code>inc</code>, <code>first</code>, and <code>map</code>. trlisp names are
        <code>Upper-Case-With-Hyphens</code>, such as <code>Inc</code>, <code>First</code>, and <code>Map</code>.
      </p>
      <p>
        The exceptions are:
      </p>
      <ul>
        <li>
          <p>
            <code>d</code>
          </p>
          <p>
            The D combinator already claims the capital 'D'. Since the <code>d</code> function is used extensively in definitions, and it is so closely related
            to the D combinator, I chose to keep it as a single, lower-case 'd'.
          </p>
        </li>
        <li>
          <p>
            <code>error</code>
          </p>
          <p>
            Java (Clojure's host) already uses <code>Error</code>.
          </p>
        </li>
        <li>
          <p>
            Conversion utilities that accept Clojure types (which are lower-cased) and return trees. E.g.,
          </p><code>str-&gt;String</code>.
        </li>
      </ul>
      <p></p>
      <p>
        Java claims <code>Byte</code> while Clojure claims <code>byte</code>, so trlisp uses <code>Bite</code> to denote eight binary digits.
      </p>
      <h3>
        Recommendations
      </h3>
      <p>
        It helped me greatly to work out the examples with a pencil and paper, and only then check their evaluations in trlisp. Letting the computer do all the
        work stymies a deeper understanding we might get by slinging around tree nodes by hand.
      </p>
      <p>
        The <a href="https://github.com/blosavio/trlisp/blob/main/test/tree_calculus/definitions_test.clj">unit testing</a> namespace (and its <a href=
        "https://github.com/blosavio/trlisp/blob/main/test/tree_calculus/exercising_test.clj">auxiliary</a>) contain working examples of every trlisp function.
      </p>
      <p>
        Finally, the <a href="https://github.com/barry-jay-personal/tree-calculus/blob/master/tree_book.pdf">tree calculus book</a> is the authoritative and
        complete reference on the subject. This <em>ReadMe</em> is merely a description of how to use trlisp to evaluate tree calculus expressions. Use it as a
        companion to the <em>Tree Calculus Book</em>.
      </p>
    </section>
    <section id="fundamental">
      <h2>
        Fundamental functions
      </h2>
      <p>
        Tree calculus functions could be defined purely in terms of <code>Δ</code>, but some judicious naming and binding helps make programming in trlisp more
        ergonomic. Let's <a href="https://blosavio.github.io/trlisp/tree-calculus.definitions.html">define</a> a small number of fundamental functions, and
        along the way, we will see the application rules in action.
      </p>
      <h3 id="K-combinator">
        K combinator
      </h3>
      <p>
        We'll start with the simplest function, the <em>K combinator</em>: simple in what it does, simple in structure, and simple in its application.
      </p>
      <p>
        The K combinator always returns the first of its two arguments.
      </p>
      <pre><code>(K Δ (Δ Δ Δ)) ;; =&gt; Δ</code></pre>
      <p>
        Given trees <code>Δ</code> and <code>(Δ Δ Δ)</code>, <code>K</code> returns <code>Δ</code>, the first argument, and discards the second argument. Here,
        we are using concrete trees to demonstrate the behavior, but <code>K</code> works the same on any pair of trees.
      </p>
      <p>
        We've already seen in our discussion of the tree calculus application rules that <a href="#apply-fork-leaf">Rule&nbsp;3</a> declares that a fork-leaf
        always returns the first of a pair of arguments. So we know that we can create a K combinator by adopting that fork-leaf pattern.
      </p>
      <p>
        Putting an expression that evaluates to a fork-leaf <code>(Δ Δ)</code> in the function position and applying it to two arguments, dispatches on
        application Rule&nbsp;3, and returns the first argument.
      </p>
      <pre><code>((Δ Δ) Δ (Δ Δ Δ)) ;; =&gt; Δ</code></pre>
      <p>
        <code>(Δ Δ)</code> evaluates to <code>K</code> so this expression returns the exact same <code>Δ</code> as before.
      </p>
      <p>
        We've demonstrated that once we've composed a tree that triggers a particular tree calculus application rule, we can use that tree to get a wanted
        behavior.
      </p>
      <p>
        In fact, trlisp's <a href=
        "https://github.com/blosavio/trlisp/blob/0f9f83904ebf16b54e8429ab5559aebce6e00b77/src/tree_calculus/definitions.clj#L102">actual definition</a> shows
        us that <code>K</code> is simply defined as <code>(Δ Δ)</code>. Now that the symbol <code>K</code> is bound to a tree that creates a fork-leaf tree
        when given two arguments, we can easily re-use the semantic idea of <em>Take the first argument, discard the second argument</em> in any future
        expression.
      </p>
      <h3 id="D-combinator">
        D combinator
      </h3>
      <p>
        A step up in complexity is the <em>D combinator</em>. Applied to three arguments, it does this.
      </p>
      <pre><code>(D x y z) = ((y z) (x z))</code></pre>
      <p>
        This operation is useful when we want to replicate an element and/or when we want to swap the order of two items.
      </p>
      <p>
        We define D like so.
      </p>
      <pre><code>(Def D (Δ (Δ Δ) (Δ Δ Δ)))</code></pre>
      <p>
        We can visualize D like this.
      </p>
      <pre>  Δ
 / \
Δ   (K Δ)
|
Δ</pre>
      <p>
        To see <code>D</code> in action, we'll assign <code>x</code>, <code>y</code>, and <code>z</code> to concrete trees, any of which may occupy the
        function position.
      </p>
      <pre><code>(def x (K Δ))</code><br><code>(def y (K Δ))</code><br><code>(def z K)</code></pre>
      <p>
        These are merely small trees with no particular semantics. We use them only because it's straightforward to apply them by hand.
      </p>
      <p>
        Let's evaluate the sub-components.
      </p>
      <pre><code>(y z) ;; =&gt; Δ</code></pre>
      <p>
        because <code>(K Δ K)</code> yields <code>Δ</code> due to application of the K combinator.
      </p>
      <p>
        The second sub-component is identical to the first.
      </p>
      <pre><code>(x z) ;; =&gt; Δ</code></pre>
      <p>
        Now let's evaluate the value of <code>(y z)</code> applied to the value of <code>(x z)</code>.
      </p>
      <pre><code>(Δ Δ) ;; =&gt; K</code></pre>
      <p>
        Let's check that against evaluating the entire expression.
      </p>
      <pre><code>((y z) (x z)) ;; =&gt; K</code></pre>
      <p>
        Finally, let's invoke trlisp's definition of <code>D</code> with <code>x</code>, <code>y</code>, and <code>z</code> as arguments.
      </p>
      <pre><code>(D x y z) ;; =&gt; K</code></pre>
      <p>
        Notice that, as with the K combinator, the D combinator is a tree deliberately composed to invoke a particular application rule, in this instance,
        Rule&nbsp;4 for fork-stems. After a couple rounds of application, we obtain the following expression.
      </p>
      <pre><code>  Δ
 / \
Δ   y  ␣  z
|
x</code></pre>
      <p>
        Rule&nbsp;4 immediately declares this to evaluate to
      </p>
      <pre><code>((y z) (x z))</code></pre>
      <p>
        which is the D combinator's essence.
      </p>
      <p>
        If we work out that sequence of evaluations by hand, we notice that D applied to the first argument <code>x</code> always eventually evaluates to
      </p>
      <pre><code>(Δ (Δ x))</code></pre>
      <p>
        which looks like this.
      </p>
      <pre><code>Δ
|
Δ
|
x</code></pre>
      <p>
        It's convenient to short-cut those steps, so we designate a function <code>d</code> such that
      </p>
      <pre><code>((d x) y z) ;; =&gt; ((y z) (x z))</code></pre>
      <p>
        which is the same result produced by the D combinator.
      </p>
      <h3 id="S-combinator">
        S combinator
      </h3>
      <p>
        The D combinator, in addition to broadcasting the third argument, also swaps the order of the first two arguments. It just so happens that there is a
        combinator that broadcasts the third argument to the first two arguments while maintaining the order.
      </p>
      <p>
        The <em>S combinator</em> works like this
      </p>
      <pre><code>(S x y z) ;; =&gt; ((x z) (y z))</code></pre>
      <p>
        and can be <a href=
        "https://github.com/blosavio/trlisp/blob/0f9f83904ebf16b54e8429ab5559aebce6e00b77/src/tree_calculus/definitions.clj#L116-L117">defined</a> in terms of
        <code>d</code>, <code>D</code>, and <code>K</code>.
      </p>
      <p>
        We can test the definition by evaluating with arguments <code>x</code>, <code>y</code>, and <code>z</code> from the previous subsection.
      </p>
      <pre><code>(= (S x y z)
   ((x z) (y z))) ;; =&gt; true</code></pre>
      <p>
        The definition for S checks out.
      </p>
      <p>
        It may be a little surprising to learn that the S combinator plays almost no role in any upcoming definition. It's main utility is that with only
        <code>S</code> and <code>K</code> in hand, we know that tree calculus is <em>S‑K&nbsp;complete</em>, and therefore can compute any function whatsoever.
      </p>
      <h3 id="I-combinator">
        I combinator
      </h3>
      <p>
        Another crucial combinator is the <em>I combinator</em>, which returns exactly its single argument.
      </p>
      <pre><code>(I x) ;; =&gt; x</code></pre>
      <p>
        The I combinator could be defined in terms of <code>S</code> and <code>K</code>, but such a definition is extensionally equivalent to trlisp's simpler
        <a href="https://github.com/blosavio/trlisp/blob/0f9f83904ebf16b54e8429ab5559aebce6e00b77/src/tree_calculus/definitions.clj#L105-L106">definition</a>,
      </p>
      <pre><code>(Δ K K)</code></pre>
      <p>
        which we can visualize like this.
      </p>
      <pre><code>  Δ
 / \
Δ   Δ
|   |
Δ   Δ</code></pre>
      <p>
        Note that the tree structure of I combinator is designed to invoke Rule&nbsp;4, applying fork-stems, then immediately thereafter applies Rule&nbsp;3,
        for fork-leaves to discard the second expression, returning exactly the argument. <em>The structure encodes the behavior.</em>
      </p>
      <p>
        The I combinator appears in many upcoming definitions, including a key role in defining Boolean entities.
      </p>
      <h3 id="Y-combinator">
        Y combinator
      </h3>
      <p>
        trlisp supports recursion via the fixpoint combinator, or <em>Y combinator</em>, used in many of the upcoming definitions. Y is awkward to use
        directly, but know that it exists and is available.
      </p>
      <h3>
        Other combinators
      </h3>
      <p>
        For completeness, trlisp also provides the <a href="https://blosavio.github.io/trlisp/tree-calculus.definitions.html#var-B">B</a>, <a href=
        "https://blosavio.github.io/trlisp/tree-calculus.definitions.html#var-C">C</a>, and <a href=
        "https://blosavio.github.io/trlisp/tree-calculus.definitions.html#var-W">W</a> combinators, but does not use them for any further purposes.
      </p>
      <p>
        It turns out that we won't often directly use any of these fundamental functions in day-to-day programming, but they are critical building blocks for
        the functions we <em>do</em> use.
      </p>
    </section>
    <section id="base">
      <h2>
        Base functions
      </h2>
      <p>
        Now we'll discuss functions that might be useful for solving day-to-day problems. We should always keep in mind that these functions are <a href=
        "https://github.com/blosavio/trlisp/blob/0f9f83904ebf16b54e8429ab5559aebce6e00b77/src/tree_calculus/definitions.clj#L129">defined</a> (almost) solely
        in terms of <code>Δ</code>, or other trees themselves defined with <code>Δ</code>, a key characteristic of tree calculus.
      </p>
      <h3 id="Boolean">
        Booleans
      </h3>
      <p>
        The two Boolean values behave like Church Booleans, with <code>True</code> returning the first of two arguments, and <code>False</code> returning the
        second of two arguments.
      </p>
      <pre><code>(True x y) ;; =&gt; x</code><br><code>(False x y) ;; =&gt; y</code></pre>
      <p>
        In addition to <code>Not</code>, trlisp provides the usual suspects: <code>And</code>, <code>Or</code>, <code>Implies</code>, and <code>Iff</code>.
        Here's just a sampling.
      </p>
      <pre><code>(And True (Not True)) ;; =&gt; False</code><br><code>(Or True False) ;; =&gt; True</code><br><code>(Iff False False) ;; =&gt; True</code><br><code>(Implies True False) ;; =&gt; False</code></pre>
      <p>
        See the <a href=
        "https://github.com/blosavio/trlisp/blob/0f9f83904ebf16b54e8429ab5559aebce6e00b77/test/tree_calculus/definitions_test.clj#L201-L236">testing
        namespace</a> for the complete truth tables.
      </p>
      <h3 id="arithmetic">
        Arithmetic
      </h3>
      <p>
        Similar to Church encoding, tree calculus represents natural numbers as repeated application of <code>K</code> such that number <em>n</em> is
        represented by <em>K<sup>n</sup>Δ</em>. Let's formulate the first few numbers and visualize them.
      </p>
      <table>
        <tr>
          <th>
            number
          </th>
          <th>
            tree
          </th>
          <th>
            visualization
          </th>
        </tr>
        <tr>
          <td>
            Zero
          </td>
          <td>
            <pre><code>Δ</code></pre>
          </td>
          <td>
            <pre><code>  Δ
</code></pre>
          </td>
        </tr>
        <tr>
          <td>
            One
          </td>
          <td>
            <pre><code>(K Δ)</code></pre>
          </td>
          <td>
            <pre><code>  Δ
 / \
Δ   Δ
</code></pre>
          </td>
        </tr>
        <tr>
          <td>
            Two
          </td>
          <td>
            <pre><code>(K (K Δ))</code></pre>
          </td>
          <td>
            <pre><code>  Δ
 / \
Δ   Δ
   / \
  Δ   Δ
</code></pre>
          </td>
        </tr>
        <tr>
          <td>
            Three
          </td>
          <td>
            <pre><code>(K (K (K Δ)))</code></pre>
          </td>
          <td>
            <pre><code>  Δ
 / \
Δ   Δ
   / \
  Δ   Δ
     / \
    Δ   Δ
</code></pre>
          </td>
        </tr>
        <tr>
          <td>
            And so on.
          </td>
        </tr>
      </table>
      <p>
        It's obnoxious to have to bash those out on the keyboard, so the <a href="https://blosavio.github.io/trlisp/tree-calculus.utilities.html">utility
        namespace</a> provides a pair of functions to interconvert integers and trees.
      </p>
      <pre><code>(nat-&gt;tree 2) ;; =&gt; [[] [[] []]]</code><br><br><code>(tree-&gt;nat (K (K Δ))) ;; =&gt; 2</code></pre>
      <p>
        All the following functions require us to supply the arguments as the tree representation, not the plain integers, so we'll be replying on
        <code>nat-&gt;tree</code> and <code>tree-&gt;nat</code>.
      </p>
      <p>
        trlisp provides the classic <em>increment</em> and <em>decrement</em> functions. Let's calculate what arrives after integer <em>One</em>.
      </p>
      <pre><code>(Successor [[] []]) ;; =&gt; [[] [[] []]]</code></pre>
      <p>
        That's…not excellent. The argument and return value are a pile of brackets.
      </p>
      <p>
        Let's insert the <code>nat-&gt;tree</code> and <code>tree-&gt;nat</code> utilities to convert the argument and return value trees back to plain
        integers.
      </p>
      <p>
        Clojure provides a handy threading macro so we don't have to read the expression from the inside out.
      </p>
      <pre><code>(-&gt; 2
    nat-&gt;tree
    Successor
    tree-&gt;nat) ;; =&gt; 3</code></pre>
      <p>
        That's a tad better.
      </p>
      <p>
        We feed plain integer <code>2</code> into <code>nat-&gt;tree</code>, which converts it into the tree representation <code>[[] [[] []]]</code>. Then, we
        feed that tree into <code>Successor</code>, which does its calculation, returning yet another tree. Finally, we feed that tree into
        <code>tree-&gt;nat</code>, which hands us an understandable integer <code>3</code>, which, since we paid attention in school, we have good reason to
        believe is the correct answer.
      </p>
      <p>
        trlisp also provides the companion function, <code>Predecessor</code>.
      </p>
      <pre><code>(-&gt; 5
    nat-&gt;tree
    Predecessor
    tree-&gt;nat) ;; =&gt; 4</code></pre>
      <p>
        trlisp provides functions for addition, subtraction, multiplication, and division.
      </p>
      <p>
        Let's demonstrate addition by first binding trees to <code>Two</code> and <code>Three</code>.
      </p>
      <pre><code>(def Two (nat-&gt;tree 2))</code><br><code>(def Three (nat-&gt;tree 3))</code><br><br><code>(-&gt; (Plus Two Three)
    tree-&gt;nat) ;; =&gt; 5</code></pre>
      <p>
        Yup. Adding two to three results in five.
      </p>
      <p>
        Beware: the <code>Divide</code> function is doubly-recursive, and performs poorly.
      </p>
      <h3 id="structures">
        Lists and tuples
      </h3>
      <p>
        trlisp implements <em>2-tuples</em> with <code>Pair</code> and accessor functions <code>First</code> and <code>Second</code>.
      </p>
      <pre><code>(Pair Two Three) ;; =&gt; [[[] [[] []]] [[] [[] [[] []]]]]</code><br><br><code>(-&gt; (Second (Pair Two Three))
    tree-&gt;nat) ;; =&gt; 3</code></pre>
      <p>
        Tree calculus lists are serial forks with the values <em>v<sub>n</sub></em> in the left branches.
      </p>
      <pre><code>  Δ
 / \
v0  Δ
   / \
  v1  Δ
     / \
    v2  Δ
       / \
      …   …</code></pre>
      <p>
        trlisp provides <code>List</code> to quickly construct a list from its arguments.
      </p>
      <p>
        <code>Bite</code> constructs an <em>8-tuple</em> of bits, while strings are constructed with <code>String</code> from Bites representing the
        characters' <span class="small-caps">ascii</span> bytecodes.
      </p>
      <p>
        Append to lists with <code>Append</code> and reverse a trlisp list with <code>Reverse</code>.
      </p>
      <h3 id="folding">
        Mapping and folding
      </h3>
      <p>
        Tree calculus defines functions for operating on elements of a list. trlisp implements a <em>map</em>ping function that applies a function to every
        element of a list a returns another list.
      </p>
      <p>
        Let's construct a list of integers.
      </p>
      <pre><code>(def our-list (List (nat-&gt;tree 2) (nat-&gt;tree 3) (nat-&gt;tree 4)))</code></pre>
      <p>
        Pretend we'd like to increment, in-place, each of those integers. The <code>Successor</code> function makes a solid choice for incrementing.
      </p>
      <p>
        The function signature for mapping is
      </p>
      <pre><code>(Map <em>function list</em>)</code></pre>
      <p>
        <code>Map</code> returns a tree, which is difficult to decipher. So we'll use <code>List-&gt;seq</code> to convert the tree calculus list into a
        Clojure sequence of tree integers, and then Clojure's <code>map</code> with <code>tree-&gt;nat</code> to convert each tree integer into a plain
        integer.
      </p>
      <pre><code>(-&gt;&gt; (Map Successor our-list)
     List-&gt;seq
     (map tree-&gt;nat)) ;; =&gt; (3 4 5)</code></pre>
      <p>
        Excellent. <code>Map</code> incremented three integers contained in our list.
      </p>
      <p>
        trlisp also implements tree calculus' <em>fold</em>ing operations. The function signature for left-folding is
      </p>
      <pre><code>(Fold-Left <em>function init list</em>)</code></pre>
      <p>
        Let's compose those arguments. We'll use <code>Plus</code> since it's easy to eyeball it's effects. We'll assign a tree to an initial value.
      </p>
      <pre><code>(def our-init (nat-&gt;tree 1))</code></pre>
      <p>
        We'll use the same list of integers from earlier, <code>our-list</code>.
      </p>
      <p>
        Now, we invoke the fold, and convert the result to an integer we can recognize.
      </p>
      <pre><code>(-&gt; (Fold-Left Plus our-init our-list)
    tree-&gt;nat) ;; =&gt; 10</code></pre>
      <p>
        <code>Fold-Left</code> adds one to two, then that result to three, then that result to four, yielding ten.
      </p>
      <p>
        <code>Fold-Right</code> works analogously.
      </p>
      <h3 id="tags">
        Tagging
      </h3>
      <p>
        Tree calculus defines a system for tagging values, removing tags, reading the tags, retrieving the values, and for applying tagged functions to tagged
        values.
      </p>
      <p>
        Based on those tagging utilities, tree calculus defines a simple type system that tags a tree with a type, which can later be checked during
        application.
      </p>
      <p>
        trlisp implements the both the tagging and type-check systems, but they're not user-friendly, nor comprehensive, so we won't discuss them further.
      </p>
      <h3 id="tree-analysis">
        Tree analysis
      </h3>
      <p>
        Tree calculus' tentpole feature is the ability of one function to inspect another function directly, without quoting. This feature is enabled by the
        fact that all entities, functions and values, are composed of the same stuff: trees.
      </p>
      <p>
        trlisp implements several functions in this category, such as measuring the size of a function, determining the equality of two functions, and running
        generic queries on the branching structure.
      </p>
      <p>
        For example, we can use the <code>Size</code> function to measure the size of the K combinator.
      </p>
      <pre><code>(-&gt; (Size K)
    tree-&gt;nat) ;; =&gt; 2</code></pre>
      <p>
        Yes, the K combinator is composed of two nodes as we expect.
      </p>
      <p>
        We could also ask if two functions are equal. Let's see if the K combinator is equal to one leaf node descendant from another node.
      </p>
      <pre><code>(Equal? K (Δ Δ)) ;; =&gt; True</code></pre>
      <p>
        Yes, the two trees are equal as we expect.
      </p>
      <p>
        Tree calculus' <em>triage</em> defines a basic system for testing for leaves, stems, or forks. With triage in hand, tree calculus goes on to define
        <em>pattern matching</em>. As I understand it, pattern-matching answers the following question.
      </p>
      <p>
        Given tree <em>A</em>,
      </p>
      <pre><code>  Δ
 / \
Δ   foo</code></pre>
      <p>
        and some target component of <em>A</em>,
      </p>
      <pre><code>foo</code></pre>
      <p>
        and test tree <em>B</em>,
      </p>
      <pre><code>  Δ
 / \
Δ   baz</code></pre>
      <p>
        What is the <em>thing</em> located in tree <em>B</em> at the same location as <code>foo</code> in tree <em>A</em>? The answer is <code>baz</code>.
      </p>
      <p>
        trlisp implements both triage and pattern matching, and they pass some rudimentary unit tests, but I am not confident the tests are correct nor
        sufficient.
      </p>
      <p>
        At any rate, we <em>should</em> be impressed with the fact that all these functions, sophisticated as they are, are <a href=
        "https://github.com/blosavio/trlisp/blob/0f9f83904ebf16b54e8429ab5559aebce6e00b77/src/tree_calculus/definitions.clj#L399">defined</a> in terms of the
        basic node operator.
      </p>
      <h3 id="evaluators">
        Self evaluators
      </h3>
      <p>
        Tree calculus demonstrates its ability for programs to act on themselves by defining four self-evaluators. trlisp implements all four:
        <em>Branch-first</em>, <em>Root</em>, <em>Root-and-branch</em>, and <em>Root-first</em> evaluate their arguments with different strategies for
        inspecting the interior structure of their arguments.
      </p>
      <p>
        See the <a href=
        "https://github.com/blosavio/trlisp/blob/0f9f83904ebf16b54e8429ab5559aebce6e00b77/test/tree_calculus/definitions_test.clj#L698-L884">testing
        namespace</a> for example usage.
      </p>
    </section>
    <section id="comments">
      <h2>
        Comments
      </h2>
      <p>
        Two of tree calculus' ideas intrigue me the most.
      </p>
      <ol>
        <li>
          <strong>Every entity is composed of the same stuff.</strong>
          <p>
            In this regard similar to lambda calculus, I find it interesting that a complete computing system can be made when functions and values are
            composed from a single basic unit. In tree calculus' case, it's the <code>Δ</code> operator. Don't miss the impressive accomplishment: All the
            functions and values introduced here are defined with various trees composed of <code>Δ</code>. trlisp, via Clojure, only provides variable binding
            and the most minimal machinery for evaluating expressions. Tree calculus does all the actual computation.
          </p>
        </li>
        <li>
          <strong>One operator plus six application rules.</strong>
          <p>
            Tree calculus' minimalism hints that it could be implemented in constrained environments, maybe a 6502 microprocessor, or a punch card machine, or
            perhaps even a marble machine.
          </p>
        </li>
      </ol>
      <p>
        I wrote trlisp so that I could evaluate tree calculus expressions to check my pencil and paper work, and to feel what it's like to work with. In that
        regard, trlisp provides that. While working through the exercises, trlisp can quickly evaluate an expression that otherwise takes multiple sheets of
        paper when written by hand.
      </p>
      <p>
        On the other hand, it is immediately apparent that trlisp is in no way a practical, general-purpose programming language. Tree calculus appears to be
        firmly in the academic realm, as its current formulation emphasizes features important to academia: proofs of correctness and completeness, etc. All
        inputs must first be converted to a tree. Every tree returned from a function must be converted back to a value that is recognizable. And causes of
        incorrect results are tedious to track down.
      </p>
      <p>
        Finally, the fact that functions and values are all the same 'type', i.e., trees, makes some expressions nonsensical.
      </p>
      <pre><code><code>(Three K) ;; =&gt; 2</code></code></pre>
      <p>
        For example, due to the way numbers are encoded into trees, a number <em>n</em> applied to anything always returns <em>n-1</em> by the fork-leaf rule.
      </p>
      <p>
        To implement a practical language, we'd need to immediately develop an account for at least strong typing (but not necessarily static typing),
        name-to-value binding, error-handling, and heterogeneous composite data structures (the features currently provided by trlisp's host, Clojure). Soon
        after that, we'd need to define performant versions of functions that operate on the generally necessary fundamental data types (i.e, arithmetic in
        binary integers and floats, substitution on strings, etc.) At that point, we'd be replicating Clojure, which wisely delegates much of that to Java. A
        monumental undertaking, but possibly rewarding.
      </p>
      <h3 id="implications">
        Implications
      </h3>
      <p>
        It's not obvious to me how someone would integrate tree calculus' node operator and application rules to an already existing programming language, or
        even if there would be advantages in doing so. And we've just discussed the formidable challenge of writing one from the ground up.
      </p>
      <p>
        On the other hand, having direct access to a function's definition does suggest some interesting possibilities. Being able to inspect, analyze,
        optimize, modify, and borrow pieces from a function could enable tasks that are not currently easy, or even possible. In recent memory, I have at least
        <a href="https://blosavio.github.io/speculoos/speculoos.utility.html#var-defpred">one utility</a> that would have been faster and more elegant to write
        if I had run-time (not compile-time) access to the function's definition. I wouldn't think it's a capability we'd use often, but it could be nice tool
        in the toolbox. Something akin to reluctantly writing a Lisp macro.
      </p>
    </section>
    <section id="references">
      <h2>
        References
      </h2>
      <h3>
        Tree calculus references
      </h3>
      <ul>
        <li>
          <p>
            Barry Jay's <a href="https://github.com/barry-jay-personal/tree-calculus/blob/master/tree_book.pdf">Reflective Programs in Tree Calculus</a> (pdf,
            2021)
          </p>
          <p>
            trlisp's primary reference. See also the <a href="https://github.com/barry-jay-personal/tree-calculus">other materials</a> in Jay's GitHub page,
            particularly the Coq proofs.
          </p>
        </li>
        <li>
          <p>
            Johannes Bader's <a href="https://treecalcul.us/">Tree Calculus</a> page
          </p>
          <p>
            Tree calculus advocacy, examples, and interactive demos. Note: The application rules are different than here, but equivalent. Bader also wrote a
            nice <a href="https://olydis.medium.com/a-visual-introduction-to-tree-calculus-2f4a34ceffc2">introduction blog post</a>.
          </p>
        </li>
        <li>
          <p>
            Timur Latypoff's <a href="https://latypoff.com/tree-calculus-visualized/">Tree calculus, visualized</a>
          </p>
        </li>
      </ul>
    </section>
    <section id="glossary">
      <h2>
        Glossary
      </h2>
      <dl>
        <dt id="apply">
          apply
        </dt>
        <dd>
          <p>
            Consume two trees, yielding a single tree according to the tree calculus rules. In trlisp, we <code>apply</code> by evaluating a list with a
            function (a <a href="#tree">tree</a>) at the head and an argument (also a tree) at its tail.
          </p>
          <p>
            An instance of applying one tree to another is an <em>application</em>. trlisp provides six distinct applications, selected by the branching
            pattern of the tree in the function position.
          </p>
        </dd>
        <dt id="argument">
          argument
        </dt>
        <dd>
          <p>
            A tree appearing in the tail of a list to be evaluated. The argument is consumed in the course of applying the function.
          </p>
          <p>
            Note: All trees may serve as an argument, even trees that are semantically functions, such as <code>Inc</code>. In other words, trees are
            first-class functions and may be passed as values and manipulated.
          </p>
        </dd>
        <dt id="define">
          define
        </dt>
        <dd>
          <p>
            Bind a name (a Cloujure symbol) to tree. That name evaluates to the original tree wherever it appears in an expression.
          </p>
        </dd>
        <dt id="fork">
          fork
        </dt>
        <dd>
          <p>
            A node with exactly two children.
          </p>
        </dd>
        <dt id="function">
          function
        </dt>
        <dd>
          <p>
            A tree appearing at the head of a list to be evaluated. The function's branching pattern determines which application rule to invoke.
          </p>
          <p>
            Note: All trees are potentially functions, i.e., any tree may competently invoke one of the applications.
          </p>
        </dd>
        <dt id="leaf">
          leaf
        </dt>
        <dd>
          <p>
            A node with exactly zero children.
          </p>
        </dd>
        <dt id="node">
          node
        </dt>
        <dd>
          <p>
            The basic unit of an unlabelled, binary tree. May be either a leaf, stem, or fork.
          </p>
        </dd>
        <dt id="stem">
          stem
        </dt>
        <dd>
          <p>
            A node with exactly one child.
          </p>
        </dd>
        <dt id="tree">
          tree
        </dt>
        <dd>
          <p>
            An arrangement of only <a href="#leaf">leafs</a>, <a href="#stem">stems</a>, and <a href="#fork">forks.</a>
          </p>
        </dd>
      </dl>
    </section><br>
    <h2>
      License
    </h2>
    <p></p>
    <p>
      This program and the accompanying materials are made available under the terms of the <a href="https://opensource.org/license/MIT">MIT License</a>.
    </p>
    <p></p>
    <p id="page-footer">
      Copyright © 2024–2025 Brad Losavio.<br>
      Compiled by <a href="https://github.com/blosavio/readmoi">ReadMoi</a> on 2025 June 13.<span id="uuid"><br>
      24d7622e-9828-4fe1-831b-4a4314e293e0</span>
    </p>
  </body>
</html>
